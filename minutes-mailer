#!/usr/bin/env python
'''send techoncrats minutes'''

from __future__ import absolute_import, print_function, unicode_literals
import argparse
import datetime
import sys
import os.path
import getpass
from request_tracker import RT, RT_URL, send_email, load_config

def loadconfig():
    '''loads configuration file'''
    config = load_config('/etc/mm.cfg')
    rtconf = config['rt']
    mail = config['mail']
    # get global values for RT etc
    global RT_HOST, RT_USER, RT_PASSWORD, RT_QUEUE, MAILHOST
    RT_HOST = rtconf['rt_host']
    RT_USER = rtconf['rt_user']
    RT_PASSWORD = rtconf['rt_password']
    MAILHOST = mail['mail_host']
    RT_QUEUE = rtconf['rt_queue']
    global TECHNOCRATS_LIST, MINUTES_LIST
    TECHNOCRATS_LIST = mail['rt_queue_email']
    MINUTES_LIST = mail['minutes_list']
    global MEETINGDAY
    meeting = config['meeting']
    MEETINGDAY = meeting['day']
    # get from address and path to minutes
    global MAIL_FROM, MINUTES_PATH
    local_conf = os.path.expanduser('~/.minutes_mailer')
    if os.path.isfile(local_conf):
        MAIL_FROM, MINUTES_PATH = get_local_conf(local_conf)
    else:
        create_config(local_conf)
        sys.exit(1)

def create_config(config):
    '''create local config file'''
    print('No local configuration found...creating')
    with open(config, 'w') as f:
        contents = [
        '[config]',
        '# email that can post to ' +  TECHNOCRATS_LIST,
        'email = ' + getpass.getuser() + '@freegeek.org',
        '# uncomment the next line to specify the directory where minutes are normally stored (recommended)',
        '# path = [directory goes here, relative to ~/]'
        ]
    f.writelines(contents)
    print('Please edit ' + config + ' to your satisfaction') 


def get_local_conf(config_file):
    '''Reads in configuration file.'''
    local_config = load_config(config_file)
    config = local_config['config']
    if not config['email']:
        print('a valid email must be supplied in ' + config_file)
    elif not config['path']:
        config['path'] = None
    return config['email'], config['path'] 
            

def read_options():
    '''read command line options'''
    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-d", "--send-draught", 
            help="email draught minutes", action="store_true")
    group.add_argument("-m", "--send-minutes", 
            help="Send final minutes. Supply ticket number as an argument",
            action="store")
    group.add_argument("-n", "--new-file", help="create a blank minutes file", 
            action="store_true")
    parser.add_argument("-D", "--date", 
            help="date of minutes. Not normally needed unless the minutes are seent out more than a week late", 
            action="store")
    parser.add_argument("-f", "--file", 
            help="file containing minutes", action="store")
    args = parser.parse_args()
    if not args.date:
        if args.send_draught:
            args.date = 'today'
        elif args.send_minutes:
            args.date = 'lastweek'
    if args.send_draught:
        action = 'draught'
    elif args.new_file:
        action = 'new'
    elif  args.send_minutes:
        action = args.send_minutes
    if args.file:
        mfile = args.file
    else:
        mfile = None
    return action, args.date, mfile
 

def create_new_minutes_file():
    '''creates a blank minutes file'''
    date = get_date('today')
    minutes_file = 'minut tes' +  '.' + str(date)
    if MINUTES_PATH:
        minutes_file = MINUTES_PATH + '/' + file
    if not os.path.exists(minutes_file):
        open(file,'a').close()
        print('Created ' + minutes_file)
        return True
    else:
        print(minutes_file + ' already exists!')
        return False


def get_file(date):
    '''returns default file name give date'''
    minutes_file = 'minutes' +  '.' + str(date)
    if MINUTES_PATH:
        minutes_file = MINUTES_PATH + '/' + file
    return minutes_file


def load_file(mfile):
    '''load file contents and return them as string'''
    with open(mfile,'rU') as f:
        contents = f.read()
    return contents

def setup_object():
    '''create request tracker opject and login'''
    rt_object = RT(RT_URL, RT_USER, RT_PASSWORD)
    rt_object.login()
    return rt_object


def send_draught(date, mfile=None):
    '''send draught minutes'''
    date = get_date(date)
    subject = 'DRAFT: Technocrats Minutes ' + str(date)
    if not mfile:
        mfile = get_file(date)
    msg = load_file(mfile)
    send_email(MAILHOST, MAIL_FROM, TECHNOCRATS_LIST, subject, msg)


def send_final(ticketno, date, mfile=None):
    '''send final minutes'''
    ticket = setup_object()
    try:
        isvalid = ticket.is_valid_ticket(RT_QUEUE, ticketno)
        if not isvalid:
            print('Not a valid ticket')
            sys.exit(1)
    except:
        print('could not connect to RT. \
            Check your network connection and try again')
        sys.exit(3)
    # TODO check if the ticket looks like minutes
    date = get_date(date)
    subject = 'Technocrats Minutes ' + str(date)
    if not mfile:
        mfile = get_file(date)
    msg = load_file(mfile)
    send_email(MAILHOST, MAIL_FROM, MINUTES_LIST, subject, msg)
    ticket.add_comment(ticketno, msg)
    ticket.set_status(ticketno, 'resolved')

def get_date(when):
    '''return the date for n weeks ago'''
    # calculate the date 
    if when == 'today':
        return weeks_ago(0, MEETINGDAY)
    elif when == 'lastweek':
        return weeks_ago(1, MEETINGDAY)
    else:
        # assume a date was specified and just return it
        # should only be the case with late minutes
        return when


def weeks_ago(weeks, weekdayno):
    '''Return a datetime object that represents the date of the day 
    n weeks ago. 0 = today or the last occurence of  that day
    1 = last week etc '''
    days = weeks * 7
    today = datetime.date.today()
    # weekday of nearest day
    weekday = datetime.date.weekday(today) % weekdayno
    timedelta = datetime.timedelta(weekday)
    date = today - timedelta
    # calculate for days ago
    timedelta = datetime.timedelta(days)
    return date - timedelta


if __name__ == "__main__":
    loadconfig()
    ACTION, DATE, MINUTESFILE = read_options()
    if ACTION == 'draught':
        send_draught(DATE, MINUTESFILE)
    elif ACTION == 'new':
        create_new_minutes_file()
    else:
        # send final minutes, action should contain ticket number
        send_final(ACTION, DATE, MINUTESFILE)

