#!/usr/bin/env python
'''send techoncrats minutes'''

from __future__ import absolute_import, print_function, unicode_literals
import argparse
import datetime
import sys
import os.path
import getpass
import re
from request_tracker import RT, RT_URL, send_email, load_config

class Error(Exception):
    '''Base class for exceptions '''
    def __init__(self, msg, exitval):
        self.msg = msg
        self.exitval = exitval

def loadconfig():
    '''loads configuration file'''
    config = load_config('/etc/mm.cfg')
    rtconf = config['rt']
    mail = config['mail']
    # get global values for RT etc
    global RT_HOST, RT_USER, RT_PASSWORD, RT_QUEUE, MAILHOST
    RT_HOST = rtconf['rt_host']
    RT_USER = rtconf['rt_user']
    RT_PASSWORD = rtconf['rt_password']
    MAILHOST = mail['mail_host']
    RT_QUEUE = rtconf['rt_queue']
    global TECHNOCRATS_LIST, MINUTES_LIST
    TECHNOCRATS_LIST = mail['rt_queue_email']
    MINUTES_LIST = mail['minutes_list']
    global MEETINGDAY
    meeting = config['meeting']
    MEETINGDAY = meeting['day']
    # get from address and path to minutes
    global MAIL_FROM, MINUTES_PATH
    local_conf = os.path.expanduser('~/.minutes_mailer')
    if  not os.path.isfile(local_conf):
        create_config(local_conf)
    MAIL_FROM, MINUTES_PATH = get_local_conf(local_conf)

def create_config(config):
    '''create local config file'''
    print('No local configuration found...creating')
    email =  getpass.getuser() + '@freegeek.org',
    if not yes_no('Is this your email' + email):
        email =  raw_input('Enter your email: ')
    print('Enter the directory where you wish to store minutes')
    print('This can be an absolute path or relative to your home dir')
    print("leave blank if you store them in your home directory or don't care") 
    path = raw_input('Enter path: ')
    if not path:
        pathline = '#path = [directory goes here, relative to ~/]'
    else:
        pathline = 'path' + path
    with open(config, 'w') as f:
        contents = [
        '[config]',
        '# email that can post to ' +  TECHNOCRATS_LIST,
        'email = ' + email
        '# uncomment the next line to specify the directory where minutes are normally stored (recommended)',
        ]
        try: 
            f.write('\n'.join(contents))
            print('Local configuration file'  + config + 'written') 
        except IOError:
            print('Could not write to Local configuration file'  + config)
            sys.exit(73)


def get_local_conf(config_file):
    '''Reads in configuration file.'''
    local_config = load_config(config_file)
    config = local_config['config']
    if not 'email' in config:
        print('a valid email must be supplied in ' + config_file)
    elif not 'path' in config:
        config['path'] = None
    return config['email'], config['path'] 
            

def read_options():
    '''read command line options'''
    parser = argparse.ArgumentParser()
    group = minutes_file[0:2] == '~/':parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-d", "--send-draught", 
            help="email draught minutes", action="store_true")
    group.add_argument("-m", "--send-minutes", 
            help="Send final minutes. Supply ticket number as an argument",
            action="store")
    group.add_argument("-n", "--new-file", help="create a blank minutes file", 
            action="store_true")
    parser.add_argument("-D", "--date", 
            help="date of minutes. Not normally needed unless the minutes are seent out more than a week late", 
            action="store")
    parser.add_argument("-f", "--file", 
            help="file containing minutes", action="store")
    args = parser.parse_args()
    if not args.date:
        if args.send_draught:
            args.date = 'today'
        elif args.send_minutes:
            args.date = 'lastweek'
    if args.send_draught:
        action = 'draught'
    elif args.new_file:
        action = 'new'
    elif  args.send_minutes:
        action = args.send_minutes
    if args.file:
        mfile = args.file
    else:
        mfile = None
    return action, args.date, mfile
 

def create_new_minutes_file():
    '''creates a blank minutes file'''
    date = get_date('today')
    minutes_file = get_file(date)
    if not os.path.exists(minutes_file):
        try:
            open(minutes_file,'a').close()
            print('Created ' + minutes_file)
            return True
        except IOError:
            print('Could not write to '  +  minutes_file)
            sys.exit(73)
    else:
        raise Error("Minutes files already exists!", 1)



def get_file(date):
    '''returns default file name + path given date(time object)'''
    minutes_file = 'minutes' +  '.' + str(date)
    if MINUTES_PATH:
        minutes_file = MINUTES_PATH + '/' + minutes_file
    if minutes_file[0:2] == '~/':
        return os.path.expanduser(minutes_file)
    elif minutes_file[0] == '/':
        return minutes_file
    else:
        return os.path.expanduser('~/' + minutes_file)


def load_file(mfile):
    '''load file contents and return them as string'''
    with open(mfile,'rU') as f:
        contents = f.read()
    return contents

def setup_object():
    '''create request tracker opject and login'''
    rt_object = RT(RT_URL, RT_USER, RT_PASSWORD)
    if not rt_object.login():
        raise Error('Could not login to RT', 3)
    else:
        return rt_object


def send_draught(date, mfile=None):
    '''send draught minutes'''
    date = get_date(date)
    subject = 'DRAFT: Technocrats Minutes ' + str(date)
    if not mfile:
        mfile = get_file(date)
    msg = load_file(mfile)
    if not send_email(MAILHOST, MAIL_FROM, TECHNOCRATS_LIST, subject, msg):
        raise Error('Could not send draught minutes', 3)


def send_final(ticketno, date, mfile=None):
    '''send final minutes'''
    ticket = setup_object()
    try:
        isvalid = ticket.is_valid_ticket(RT_QUEUE, ticketno)
        if not isvalid:
            raise Error('Not a valid ticket', 1)
        else:
            subject = ticket.get_subject(ticketno)
            if not match_minutes(subject):
                print('the subject of ' + str(ticketno) + ' is ' + subject)
                print("This does not look like the correct  ticket")
                if not yes_no('Proceed'):
                    raise Error('ticket mismatch, aborting.', 0)
    except:
        raise('could not connect to RT. \
            Check your network connection and try again', 3)
        
    date = get_date(date)
    subject = 'Technocrats Minutes ' + str(date)
    if not mfile:
        mfile = get_file(date)
    msg = load_file(mfile)
    if not send_email(MAILHOST, MAIL_FROM, MINUTES_LIST, subject, msg):
         raise Error("Could not send email to " + MINUTES_LIST, 3)
     else:
         print('sent minutes to ' + MINUTES_LIST)
    if not ticket.add_comment(ticketno, msg):
         raise Error ("Could not add minutes to ticket " + ticket no, 3)
     else:    
        print('added  minutes to ticket ' + ticketno)
    if not ticket.set_status(ticketno, 'resolved')
         raise Error ("Could resolve ticket " + ticket no, 3)
     else:    
        print('Resolved ticket ' + ticketno)
        


def match_minutes(subject):
    '''checks to see if subject lines looks like minutes'''
    match = re.compile('minutes', re.IGNORECASE)
    if match.search(subject):
        return True
    else:
        return False


def yes_no(warning=None):
    '''get a yes no answer, true if yes'''
    print(warning + '[Y/N]?')
    answer =  sys.stdin.read(1)
    if answer == 'y' or answer == 'Y':
        return True
    elif answer == 'n' or answer == 'N':
        return False
    else:
        print 'please answer y[es] or [n]o'
        return yes_no(warning)


def get_date(when):
    '''return the date for n weeks ago'''
    # calculate the date 
    if when == 'today':
        return weeks_ago(0, MEETINGDAY)
    elif when == 'lastweek':
        return weeks_ago(1, MEETINGDAY)
    else:
        # assume a date was specified and just return it
        # should only be the case with late minutes
        return when


def weeks_ago(weeks, weekdayno):
    '''Return a datetime object that represents the date of the day 
    n weeks ago. 0 = today or the last occurence of  that day
    1 = last week etc '''
    days = weeks * 7
    today = datetime.date.today()
    # weekday of nearest day
    weekday = datetime.date.weekday(today) % int(weekdayno)
    timedelta = datetime.timedelta(weekday)
    date = today - timedelta
    # calculate for days ago
    timedelta = datetime.timedelta(days)
    return date - timedelta


if __name__ == "__main__":
    ACTION, DATE, MINUTESFILE = read_options()
    loadconfig()
    if ACTION == 'draught':
        try:
            send_draught(DATE, MINUTESFILE)
        except Error as error:
            print error.msg
            sys.exit(error.exitval)

    elif ACTION == 'new':
        try:
            create_new_minutes_file()
        except Error as error:
            print error.msg
            sys.exit(error.exitval)
    else:
        # send final minutes, action should contain ticket number
        try:
            send_final(ACTION, DATE, MINUTESFILE)
        except Error as error:
            print error.msg
            sys.exit(error.exitval)
    sys.exit(0)
