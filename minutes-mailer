#!/usr/bin/env python
'''send techoncrats minutes'''

from __future__ import absolute_import, print_function, unicode_literals
import argparse
import datetime
import sys
import os.path
import getpass
import re
import ConfigParser

from request_tracker import RT, send_email, 

class Error(Exception):
    '''Base class for exceptions '''
    def __init__(self, msg, exitval):
        self.msg = msg
        self.exitval = exitval

def loadconfig():
    '''loads configuration file'''
    config = ConfigParser.SafeConfigParser()
    config.read('/etc/mm.cfg')
    rt = {}
    rt['host'] = config.get('rt', 'rt_host')
    rt['queue'] = config.get('rt', 'rt_queue')
    mail = {}
    mail['host'] = config.get('mail', 'host')
    mail['minutes list'] = config.get('mail', 'minutes_list')
    mail['queue'] = config.get('mail', 'rt_queue_email')
    misc = {}
    misc['meeting day'] = int(config.get('meeting', 'day'))
    local_conf = os.path.expanduser('~/.minutes_mailer')
    if  not os.path.isfile(local_conf):
        create_config(local_conf)
    config.read(local_conf)
    mail['email'] = config.get('mail', 'email')
    if config.has_option('minutes','path'):
        misc['minutes path'] = config.get('minutes','path')
    else:
        misc['minutes path'] = None
    rt['user'] = config.get('rt', 'rtuser')
    if config.has_option('rt','nopassword'):
        rt['nopassword'] = True
    return rt, mail, misc


  def create_config(configfile):
    '''create local config file'''
    print('No local configuration found...creating')
    config = ConfigParser.SafeConfigParser()
    email, path, rtuser, rtpath = get_user_config()
    config.add_section('minutes')
    if path:
        config.set('minutes', 'path', path)
    config.add_section('mail')
    config.set('mail', 'email', email)
    config.add_section('rt')
    config.set('rt', 'rtuser', rtuser)
    if rtpass:
        set_password('rt', rtuser, rtpass)
    else:
        config.set('rt', 'nopassword', true)
    try:
        with open(configfile, 'wb') as cfile:
            config.write(cfile)
    except ConfigParser.Error as error:
        print('cound not write config file. Eror:')
        sysexit(error.args, 73)
    # add comment about path if not set
    if not path:
        add_path_comment(configfile)
    else:
        print('Local configuration file'  + config + 'created')

def get_user_config():
    email =  getpass.getuser() + '@freegeek.org',
    if not yes_no('Is this your email' + email):
        email =  raw_input('Enter your email: ')
    print(  "Enter the directory where you wish to store minutes\n"  \
        "This can be an absolute path or relative to your home dir\n" \
        "leave blank if you store them in your home directory or don't care") 
    path = raw_input('Enter path: ')
    rtuser = raw_input('Please enter your RT user')
    print('Please enter the password associated with this account\n' \
        'This will be stored in your keyring\n' \
        'enter a blank line if you wish to be prompted everytime instead')
    rtpass = getpass.getpass()
    return email, path, rtuser, rtpass

def add_path_comment(configfilei, slist):
        with open(configfile, 'a') as f:
            contents = [
            '# uncomment the next line to specify the directory where minutes are normally stored (recommended)',
            '#path = [directory goes here, relative to ~/]'
            ]
            try: 
                f.write('\n'.join(contents))
                print('Local configuration file'  + config + 'created') 
            except IOError:
                error = 'Could not write to local configuration file: ' \
                        + config
                sysexit(error, 73)


def read_options():
    '''read command line options'''
    parser = argparse.ArgumentParser()
    group = minutes_file[0:2] == '~/':parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-d", "--send-draught", 
            help="email draught minutes", action="store_true")
    group.add_argument("-m", "--send-minutes", 
            help="Send final minutes. Supply ticket number as an argument",
            action="store")
    group.add_argument("-n", "--new-file", help="create a blank minutes file", 
            action="store_true")
    parser.add_argument("-D", "--date", 
            help="date of minutes. Not normally needed unless the minutes are seent out more than a week late", 
            action="store")
    parser.add_argument("-f", "--file", 
            help="file containing minutes", action="store")
    args = parser.parse_args()
    if not args.date:
        if args.send_draught:
            args.date = 'today'
        elif args.send_minutes:
            args.date = 'lastweek'
    if args.send_draught:
        action = 'draught'
    elif args.new_file:
        action = 'new'
    elif  args.send_minutes:
        action = args.send_minutes
    if args.file:
        mfile = args.file
    else:
        mfile = None
    return action, args.date, mfile
 

def get_file(date):
    '''returns default file name + path given date(time object)'''
    minutes_file = 'minutes' +  '.' + str(date)
    if MINUTES_PATH:
        minutes_file = MINUTES_PATH + '/' + minutes_file
    if minutes_file[0:2] == '~/':
        return os.path.expanduser(minutes_file)
    elif minutes_file[0] == '/':
        return minutes_file
    else:
        return os.path.expanduser('~/' + minutes_file)


def load_file(mfile):
    '''load file contents and return them as string'''
    with open(mfile,'rU') as f:
        contents = f.read()
    return contents

def setup_object(url, user, password):
    '''create request tracker opject and login'''
    rt_object = RT(url, user, password)
    if not rt_object.login():
        raise Error('Could not login to RT', 3)
    else:
        return rt_object

def get_rtconf(rtconf):
    '''get rtconfig'''
    rturl = 'http://' + rtconf['host'] + '/REST/1.0/'
    rtuser = rtconf['user']
    if 'nopassword' in rtconf:
        rtpass = getpass.getpass('Enter RT password']
    else:
        rtpass = get_password('rt', rtuser)
   return rturl, rtqueue, rtuser, rtpass

#TODO IMPLEMENT
def get_password(section, user):
    '''get a password from users keyring'''
    pass

#TODO IMPLEMENT
def set_password(section, user, password):
    '''set a password in users keyring'''
    pass

def match_minutes(subject):
    '''checks to see if subject lines looks like minutes'''
    match = re.compile('minutes', re.IGNORECASE)
    if match.search(subject):
        return True
    else:
        return False


def yes_no(warning=None):
    '''get a yes no answer, true if yes'''
    print(warning + '[Y/N]?')
    answer =  sys.stdin.read(1)
    if answer == 'y' or answer == 'Y':
        return True
    elif answer == 'n' or answer == 'N':
        return False
    else:
        print 'please answer y[es] or [n]o'
        return yes_no(warning)


def get_date(when, day):
    '''return the date for n weeks ago'''
    # calculate the date 
    if when == 'today':
        return weeks_ago(0, day)
    elif when == 'lastweek':
        return weeks_ago(1, day)
    else:
        # assume a date was specified and just return it
        # should only be the case with late minutes
        return when

def get_minutes_path(config):
    '''get path form config if any'''
    misc = config['misc']
    if 'minutes path' in misc:
        return misc['minutes path']
    else:
        return None

def weeks_ago(weeks, weekdayno):
    '''Return a datetime object that represents the date of the day 
    n weeks ago. 0 = today or the last occurence of  that day
    1 = last week etc '''
    days = weeks * 7
    today = datetime.date.today()
    # weekday of nearest day
    weekday = datetime.date.weekday(today) % int(weekdayno)
    timedelta = datetime.timedelta(weekday)
    date = today - timedelta
    # calculate for days ago
    timedelta = datetime.timedelta(days)
    return date - timedelta

def sysexit(message, exit_value):
    print(message)
    sys.exit(exit_val)


def create_new_minutes_file(path = None):
    '''creates a blank minutes file'''
    day = get_day(config)
    path  = get_minutes_path(config)
    date = get_date('today', day)
    minutes_file = get_file(date, path)
    if not os.path.exists(minutes_file):
        try:
            open(minutes_file,'a').close()
            print('Created ' + minutes_file)
            return True
        except IOError:
            error = 'Could not write to '  +  minutes_file
            sys.exit(error, 73)
    else:
        raise Error("Minutes files already exists!", 1)


def send_draught(config, date, mfile=None):
    '''send draught minutes'''
    day = get_day(config)
    path  = get_minutes_path(config)
    date = get_date(date, day)
    mail=config['mail']
    subject = 'DRAFT: Technocrats Minutes ' + str(date)
    if not mfile:
        mfile = get_file(date, path)
    msg = load_file(mfile)
    if not send_email(mail['host'], mail['email'], mail['queue'], subject, msg):
        raise Error('Could not send draught minutes', 3)


def send_final(config, ticketno, date, mfile=None):
    '''send final minutes'''
    rtconf = config['rt']
    mail = config['mail']
    day = get_day(config)
    path  = get_minutes_path(config)
    rturl, rtqueue, rtuser, rtpass = get_rtconf(rtconf)
    ticket = setup_object(rturl, rtuser, rtpass)
    try:
        isvalid = ticket.is_valid_ticket(rtqueue, ticketno)
        if not isvalid:
            raise Error('Not a valid ticket', 1)
        else:
            subject = ticket.get_subject(ticketno)
            if not match_minutes(subject):
                print('the subject of ' + str(ticketno) + ' is ' + subject)
                print("This does not look like the correct  ticket")
                if not yes_no('Proceed'):
                    raise Error('ticket mismatch, aborting.', 0)
    except:
        raise('could not connect to RT. \
            Check your network connection and try again', 3)
    date = get_date(date, day)
    subject = 'Technocrats Minutes ' + str(date)
    if not mfile:
        mfile = get_file(date, path)
    msg = load_file(mfile)
    minuteslist = mail['minute list']
    if not send_email(mail['host'], mail['email'], minuteslist, 
            subject, msg):
         raise Error("Could not send email to " + minutelist, 3)
     else:
         print('sent minutes to ' + minuteslist)
    if not ticket.add_comment(ticketno, msg):
         raise Error ("Could not add minutes to ticket " + ticket no, 3)
     else:    
        print('added  minutes to ticket ' + ticketno)
    if not ticket.set_status(ticketno, 'resolved')
         raise Error ("Could resolve ticket " + ticket no, 3)
     else:    
        print('Resolved ticket ' + ticketno)
        

if __name__ == "__main__":
    action, date, minutesfile = read_options()
    # load config as dictionaries
    rt, mail, misc = loadconfig()
    config = {'rt' : rt , 'mail' : mail, 'misc', misc}
    if ['minutes path']
    if action == 'new':
        try:
            create_new_minutes_file(config)
        except Error as error:
            sysexit(error.msg, error.exitval)

    elif action == 'draught':
        try:
            send_draught(config, date, minutesfile)
        except Error as error:
            sysexit(error.msg, error.exitval)
        else:
        # send final minutes, action should contain ticket number
        try:
            send_final(config, action, date, minutesfile)
        except Error as error:
            sysexit(error.msg, error.exitval)

    sys.exit(0)  
    


